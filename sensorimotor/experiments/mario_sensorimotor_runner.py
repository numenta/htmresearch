#!/usr/bin/env python
# ----------------------------------------------------------------------
# Numenta Platform for Intelligent Computing (NuPIC)
# Copyright (C) 2015, Numenta, Inc.  Unless you have an agreement
# with Numenta, Inc., for a separate license for this software code, the
# following terms and conditions apply:
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see http://www.gnu.org/licenses.
#
# http://numenta.org/licenses/
# ----------------------------------------------------------------------

import csv
import numpy
import time

from nupic.bindings.math import GetNTAReal
from nupic.research.monitor_mixin.monitor_mixin_base import MonitorMixinBase
from nupic.research.monitor_mixin.temporal_memory_monitor_mixin import (
  TemporalMemoryMonitorMixin)
from sensorimotor.fast_general_temporal_memory import (
  FastGeneralTemporalMemory as GeneralTemporalMemory)
# Uncomment the line below to use GeneralTemporalMemory
# from sensorimotor.general_temporal_memory import GeneralTemporalMemory

# Mixin class for TM statistics
#class TMI(TemporalMemoryInspectMixin, GeneralTemporalMemory): pass
class MonitoredGeneralTemporalMemory(TemporalMemoryMonitorMixin,
                                     GeneralTemporalMemory): pass

"""
This program forms the simplest test of sensorimotor sequence inference
with 1D patterns. We present a sequence from a single 1D pattern. The
TM is initialized with multiple cells per column but should form a
first order representation of this sequence.
"""

realDType = GetNTAReal()



class MarioSensorimotorRunner(object):
  DEFAULT_TM_PARAMS = {
    # These should be decent for most experiments, shouldn't need to override
    # these too often. Might want to increase cellsPerColumn for capacity
    # experiments.
    "cellsPerColumn": 8,
    "initialPermanence": 0.5,
    "connectedPermanence": 0.6,
    "permanenceIncrement": 0.1,
    "permanenceDecrement": 0.02,

    # from params/online/reasonable/1024.yaml
    "columnDimensions": [1024],
    "minThreshold": 20,
    "maxNewSynapseCount": 30,
    "activationThreshold": 20
  }


  def __init__(self, tmOverrides=None, tpOverrides=None, seed=42):
    # Initialize Layer 4 temporal memory
    params = dict(self.DEFAULT_TM_PARAMS)
    params.update(tmOverrides or {})
    params["seed"] = seed
    self._checkParams(params)
    self.tm = MonitoredGeneralTemporalMemory(mmName="TM", **params)


  def _checkParams(self, params):
    for k,v in params.iteritems():
      if v == "Sorry":
        raise RuntimeError("Param "+k+" must be specified")
  

  def _getSequences(self, path):
    # Pull the sensor and motor sequences previously generated by Mario API
    with open(path + "sensorySDRs.csv", "rb") as f:
      reader = csv.reader(f)
      sensorySDRs = list(reader)
    with open(path + "motorSDRs.csv", "rb") as f:
      reader = csv.reader(f)
      motorSDRs = list(reader)

    return (sensorySDRs, motorSDRs)


  def feed(self, sequences, tmLearn=True, tpLearn=None, verbosity=0,
           showProgressInterval=None):
    # Note: not setup for TP...
    # https://github.com/numenta/nupic.research/blob/master/sensorimotor/sensorimotor/sensorimotor_experiment_runner.py#L131
    """
    Feed the given sequences to the HTM algorithms.
    @param tmLearn:   (bool)      Either False, or True
    @param tpLearn:   (None,bool) Either None, False, or True. If None,
                                  temporal pooler will be skipped.
    @param showProgressInterval: (int) Prints progress every N iterations,
                                       where N is the value of this param
    """
#    (sensorSequence,
#     motorSequence,
#     sensorimotorSequence,
#     sequenceLabels) = sequences
    (sensorSequence, motorSequence) = sequences
  
    currentTime = time.time()

    for i in xrange(len(sensorSequence)):
      sensorPattern = sensorSequence[i]
      motorPattern = motorSequence[i]
      sensorimotorPattern = sensorimotorSequence[i]
      
      tm.compute(sensorPattern,  # here the sequences are e.g. set([224, 480, 195, 277, 235,...])
                activeExternalCells=motorPattern,
                formInternalConnections=True,
                learn=tmLearn)

    if (showProgressInterval is not None
      and i > 0
      and i % showProgressInterval == 0):
      print ("Fed {0} / {1} elements of the sequence "
             "in {2:0.2f} seconds.".format(
               i, len(sensorSequence), time.time() - currentTime))
      currentTime = time.time()

    if verbosity >= 2:
      traces = []
      traces += self.tm.mmGetDefaultTraces(verbosity=verbosity)
      if tpLearn is not None:
        traces += self.tp.mmGetDefaultTraces(verbosity=verbosity)
      print MonitorMixinBase.mmPrettyPrintTraces(
        traces, breakOnResets=self.tm.mmGetTraceResets())
      print

#    return tm.getStatistics()


#if __name__ == "__main__":
#  start = time.time()
#  
#  # Initializations
#  print "Setting up the experiment"
#  runner = MarioSensorimotorRunner()
#  sequences = runner._getSequences("/Users/alavin/nta/marioHTM/")
#  for seq in sequences:
#    seq = formatSDRs(seq)
#  import pdb; pdb.set_trace()
#  # Train and test
#  print "Training TM on sequences"
#  runner.feed(sequences, verbosity=2, showProgressInterval=50)
#  print "Testing TM on sequences"
#  runner.feed(sequences, tmLearn=False, verbosity=2, showProgressInterval=50)
#
#  elapsed = int(time.time() - start)
#  print "Total time: {0:2} seconds".format(elapsed)
